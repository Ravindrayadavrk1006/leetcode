
/*  
    idea---> simple approach of pre-order travesal
    we are having a variable which checks if at any point checker becomes true we don't do anything further

    we are pushing the current element in answer array and poping from if we don't have the checker true
    checker is set to true if we got answer from (left and right) or (left and root) or (right and root)

*/
class Solution {
bool checker = false;
bool helper(TreeNode* root, TreeNode* p, TreeNode* q, vector<TreeNode*>& ans){
    if(root == NULL)return false;
    cout<<"current root"<<root->val<<" checker "<<checker<<endl;
    cout<<"checker value"<<checker<<endl;

    ans.push_back(root);
    bool left= false, right = false, is_root = false; 

    //if current root is equal to p or q
    if(root == q || root == p){
        is_root = true;
    }
    left = helper(root->left,p,q, ans);
    if(!checker)right = helper(root->right, p, q, ans);


    //if we don't have answer at the current root we remove the current root
    if(!checker){
        if(((left && right) || (right && is_root) || (left && is_root)) == false){
        ans.pop_back();
    }
    //if we have the answer we set the checkr to true
    else{
        checker = true;
    }
    }
    return is_root || left || right;
}
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        vector<TreeNode*> ans;
        helper(root,p,q, ans);
        //print the last node
        cout <<"size of vector"<<ans.size();
        return ans[ans.size()-1];
    }
};
